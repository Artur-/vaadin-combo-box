<!--
@element vaadin-combo-box-overlay
-->

<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-list/iron-list.html">
<link rel="import" href="../iron-resizable-behavior/iron-resizable-behavior.html">
<link rel="import" href="../paper-styles/shadow.html">
<link rel="import" href="vaadin-overlay-behavior.html">
<link rel="import" href="vaadin-combo-box-item.html">
<link rel="import" href="vaadin-spinner.html">
<link rel="import" href="vaadin-overlay.html">

<dom-module id="vaadin-combo-box-overlay">
  <template>
    <vaadin-overlay id="overlay" opened="[[opened]]" loading$="[[loading]]" position-target="[[positionTarget]]" on-template-changed="_templateChanged">
      <template>
        <style>
          :host([opened][loading]) {
            display: block !important;
            height: 58px;
          }

          #scroller {
            overflow: auto;

            /* Fixes item background from getting on top of scrollbars on Safari */
            transform: translate3d(0, 0, 0);

            /* Enable momentum scrolling on iOS (iron-list v1.2+ no longer does it for us) */
            -webkit-overflow-scrolling: touch;
          }

          #selector {
            --iron-list-items-container: {
              border-top: 8px solid transparent;
              border-bottom: 8px solid transparent;
            };
          }

          #selector vaadin-combo-box-item {
            cursor: pointer;
            padding: 13px 16px;
            color: var(--primary-text-color);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
          }

          #selector:not([touch-device]) vaadin-combo-box-item:hover,
          #selector vaadin-combo-box-item[focused] {
            background: #eee;
          }

          #selector vaadin-combo-box-item[selected] {
            color: var(--primary-color);
          }

          #selector vaadin-combo-box-item[hidden] {
            display: none;
          }
        </style>
        <vaadin-spinner active="[[loading]]"></vaadin-spinner>
        <div id="scroller" scroller="[[_scroller]]"
            on-tap="_stopPropagation"
            on-touchstart="_onTouchStart"
            on-touchend="_preventDefault"
            on-scroll="_onScroll"
            hidden$="[[loading]]">
          <iron-list
              id="selector"
              touch-device$="[[touchDevice]]"
              role="listbox"
              items="[[_items]]"
              scroll-target="[[_scroller]]">
            <template>
              <vaadin-combo-box-item
                  on-tap="_onTap"
                  index="[[index]]"
                  item="[[item]]"
                  label="[[getItemLabel(item)]]"
                  selected="[[_isItemSelected(item, _selectedItem)]]"
                  role$="[[_getAriaRole(index)]]"
                  aria-selected$="[[_getAriaSelected(_focusedIndex,index)]]"
                  focused="[[_isItemFocused(_focusedIndex,index)]]">
              </vaadin-combo-box-item>
            </template>
          </iron-list>
        </div>
      </template>
    </vaadin-overlay>
  </template>
</dom-module>

<script>
  Polymer({
    is: 'vaadin-combo-box-overlay',

    behaviors: [Polymer.IronResizableBehavior],

    properties: {

      /**
       * True if the device supports touch events.
       */
      touchDevice: {
        type: Boolean,
        reflectToAttribute: true,
        value: function() {
          try {
            document.createEvent('TouchEvent');
            return true;
          } catch (e) {
            return false;
          }
        }
      },

      opened: Boolean,

      /*
       * `true` when new items are being loaded.
       */
      loading: {
        type: Boolean,
        value: false,
        reflectToAttribute: true,
        observer: 'notifyResize'
      },

      /**
       * The element to position/align the dropdown by.
       */
      positionTarget: {
        type: Object
      },

      /**
       * Vertical offset for the overlay position.
       */
      verticalOffset: {
        type: Number,
        value: 0
      },

      /**
       * If `true`, overlay is aligned above the `positionTarget`
       */
      _alignedAbove: {
        type: Boolean,
        value: false
      },

      _selectedItem: {
        type: Object
      },

      _items: {
        type: Object
      },

      _focusedIndex: {
        type: Number,
        notify: true,
        value: -1,
        observer: '_focusedIndexChanged'
      },

      _focusedItem: {
        type: String,
        computed: '_getFocusedItem(_focusedIndex)'
      },

      _itemLabelPath: {
        type: String,
        value: 'label'
      },

      _itemValuePath: {
        type: String,
        value: 'value'
      },

      _notTapping: Boolean,

      _ignoreTaps: Boolean,
    },

    listeners: {
      'iron-resize': '_setPosition'
    },

    ready: function() {
      this._patchWheelOverScrolling();

      // Stamping with an empty object instead of null
      // will resolve templatizer issues in P2 that previously
      // required calling _flushProperties/_enableProperties.
      this._patchIronListStamping();

      // IE11: when scrolling with mouse, the focus goes to the scroller.
      // This causes the overlay closing due to defocusing the input field.
      // Prevent focusing the scroller by setting `unselectable="on"`.
      if (/Trident/.test(navigator.userAgent)) {
        this.$.scroller.setAttribute('unselectable', 'on');
      }
    },

    observers: ['_openedChanged(opened)'],

    /** */
    // TODO: remove
    created: function() {
      this._boundSetPosition = this._setPosition.bind(this);
    },

    notifyResize: function() {
      this._setPosition();
    },

    _maxHeight: function(targetRect) {
      var margin = 8;
      var minHeight = 116; // Height of two items in combo-box
      var bottom = Math.min(window.innerHeight, document.body.scrollHeight - document.body.scrollTop);

      if (this._alignedAbove) {
        return Math.max(targetRect.top - margin + Math.min(document.body.scrollTop, 0), minHeight) + 'px';
      } else {
        return Math.max(bottom - targetRect.bottom - margin, minHeight) + 'px';
      }
    },

    _openedChanged: function(opened) {
      if (opened) {
        this.$.overlay.style.position = this._isPositionFixed(this.positionTarget) ? 'fixed' : 'absolute';
        window.addEventListener('scroll', this._boundSetPosition, true);
        this._setPosition();
      } else {
        window.removeEventListener('scroll', this._boundSetPosition, true);
      }
    },

    _isPositionFixed: function(element) {
      var offsetParent = this._getOffsetParent(element);

      return window.getComputedStyle(this._unwrapIfNeeded(element)).position === 'fixed' ||
        (offsetParent && this._isPositionFixed(offsetParent));
    },

    _getOffsetParent: function(element) {
      if (element.assignedSlot) {
        return element.assignedSlot.parentElement;
      } else if (element.parentElement) {
        return element.offsetParent;
      }

      var parent = Polymer.dom(element).parentNode;

      if (parent && parent.nodeType === 11 && parent.host) {
        return parent.host; // parent is #shadowRoot
      }
    },

    _verticalOffset: function(overlayRect, targetRect) {
      if (this._alignedAbove) {
        return -overlayRect.height;
      } else {
        return targetRect.height + this.verticalOffset;
      }
    },

    _unwrapIfNeeded: function(element) {
      var isWrapped = Polymer.Settings.hasShadow && !Polymer.Settings.nativeShadow;
      return isWrapped ? window.unwrap(element) : element;
    },

    _templateChanged: function(e) {
      // TODO: rename to _selector
      this.$.selector = this.$.overlay.root.querySelector('#selector');
      this._scroller = this.$.scroller = this.$.overlay.root.querySelector('#scroller');
    },

    _setPosition: function(e) {
      if (e && e.target) {
        var target = e.target === document ? document.body : e.target;
        var parent = this._unwrapIfNeeded(this.$.overlay.parentElement);
        if (!(target.contains(this.$.overlay) || target.contains(this.positionTarget)) || parent !== document.body) {
          return;
        }
      }

      if (!this.positionTarget) {
        return;
      }

      var targetRect = this.positionTarget.getBoundingClientRect();
      this._alignedAbove = this._shouldAlignAbove();

      // TODO: this is using legacy API:
      // https://www.polymer-project.org/2.0/docs/api/mixins/Polymer.LegacyElementMixin#method-getComputedStyleValue
      this._scroller.style.maxHeight = this.getComputedStyleValue('--vaadin-combo-box-overlay-max-height') || '65vh';

      // overlay max height is restrained by the #scroller max height which is set to 65vh in CSS.
      this.$.overlay.style.maxHeight = this._maxHeight(targetRect);

      // we need to set height for iron-list to make its `firstVisibleIndex` work correctly.
      this.$.selector.style.maxHeight = this._maxHeight(targetRect);

      var overlayRect = this.$.overlay.getBoundingClientRect();
      this._translateX = targetRect.left - overlayRect.left + (this._translateX || 0);
      this._translateY = targetRect.top - overlayRect.top + (this._translateY || 0) +
        this._verticalOffset(overlayRect, targetRect);

      var _devicePixelRatio = window.devicePixelRatio || 1;
      this._translateX = Math.round(this._translateX * _devicePixelRatio) / _devicePixelRatio;
      this._translateY = Math.round(this._translateY * _devicePixelRatio) / _devicePixelRatio;
      this.$.overlay.translate3d(this._translateX + 'px', this._translateY + 'px', '0');

      this.$.overlay.style.width = this.positionTarget.clientWidth + 'px';

      this.updateViewportBoundaries();
    },

    _shouldAlignAbove: function() {
      var spaceBelow = (
          window.innerHeight -
          this.positionTarget.getBoundingClientRect().bottom -
          Math.min(document.body.scrollTop, 0)
        ) / window.innerHeight;

      return spaceBelow < 0.30;
    },

    /** */

    _patchIronListStamping: function() {
      var stamp = this.$.selector.stamp;
      this.$.selector.stamp = function(value) {
        if (value === null) {
          value = {};
        }

        return stamp.call(this, value);
      };
    },

    _getFocusedItem: function(focusedIndex) {
      if (focusedIndex >= 0) {
        return this._items[focusedIndex];
      }
    },

    _isItemSelected: function(item, selectedItem) {
      return item === selectedItem;
    },

    _onTap: function(e) {
      if (!this._notTapping && !this._ignoreTaps) {
        this.fire('selection-changed', {item: e.model.item});
      }
    },

    _onTouchStart: function() {
      this._notTapping = false;
      this.async(function() {
        this._notTapping = true;
      }, 300);
    },

    _onScroll: function() {
      this._ignoreTaps = true;
      this.debounce('restore-taps', function() {
        this._ignoreTaps = false;
      }, 300);
    },

    /**
     * Gets the index of the item with the provided label.
     * @return {Number}
     */
    indexOfLabel: function(label) {
      if (this._items && label) {
        for (var i = 0; i < this._items.length; i++) {
          if (this.getItemLabel(this._items[i]).toString().toLowerCase() ===
              label.toString().toLowerCase()) {
            return i;
          }
        }
      }

      return -1;
    },

    /**
     * Gets the label string for the item based on the `_itemLabelPath`.
     * @return {String}
     */
    getItemLabel: function(item) {
      var label = item ? this.get(this._itemLabelPath, item) : undefined;
      if (label === undefined) {
        label = item ? item.toString() : '';
      }
      return label;
    },

    _isItemFocused: function(focusedIndex, itemIndex) {
      return focusedIndex == itemIndex;
    },

    _getAriaSelected: function(focusedIndex, itemIndex) {
      return this._isItemFocused(focusedIndex, itemIndex).toString();
    },

    _getAriaRole: function(itemIndex) {
      return itemIndex !== undefined ? 'option' : false;
    },

    _focusedIndexChanged: function(index) {
      if (index >= 0) {
        this._scrollIntoView(index);
      }
    },

    _scrollIntoView: function(index) {
      var visibleItemsCount = this._visibleItemsCount();
      if (visibleItemsCount === undefined) {
        // Scroller is not visible. Moving is unnecessary.
        return;
      }

      var targetIndex = index;

      if (index > this.$.selector.lastVisibleIndex - 1) {
        // Index is below the bottom, scrolling down. Make the item appear at the bottom.
        targetIndex = index - visibleItemsCount + 1;
      } else if (index > this.$.selector.firstVisibleIndex) {
        // The item is already visible, scrolling is unnecessary per se. But we need to trigger iron-list to set
        // the correct scrollTop on the scrollTarget. Scrolling to firstVisibleIndex.
        targetIndex = this.$.selector.firstVisibleIndex;
      }
      this.$.selector.scrollToIndex(Math.max(0, targetIndex));

      // Sometimes the item is partly below the bottom edge, detect and adjust.
      var pidx = this.$.selector._getPhysicalIndex(index),
        physicalItem = this.$.selector._physicalItems[pidx];
      if (!physicalItem) return;
      var physicalItemRect = physicalItem.getBoundingClientRect(),
        scrollerRect = this._scroller.getBoundingClientRect(),
        scrollTopAdjust = physicalItemRect.bottom - scrollerRect.bottom + this._viewportTotalPaddingBottom;
      if (scrollTopAdjust > 0) {
        this._scroller.scrollTop += scrollTopAdjust;
      }
    },

    ensureItemsRendered: function() {
      this.$.selector._render();
    },

    adjustScrollPosition: function() {
      if (this._items) {
        this._scrollIntoView(this._focusedIndex);
      }
    },

    /**
     * We want to prevent the kinetic scrolling energy from being transferred from the overlay contents over to the parent.
     * Further improvement ideas: after the contents have been scrolled to the top or bottom and scrolling has stopped, it could allow
     * scrolling the parent similarily to touch scrolling.
     */
    _patchWheelOverScrolling: function() {
      var selector = this.$.selector;
      selector.addEventListener('wheel', function(e) {
        var scroller = selector._scroller || selector.scrollTarget;
        var scrolledToTop = scroller.scrollTop === 0;
        var scrolledToBottom = (scroller.scrollHeight - scroller.scrollTop - scroller.clientHeight) <= 1;

        if (scrolledToTop && e.deltaY < 0) {
          e.preventDefault();
        } else if (scrolledToBottom && e.deltaY > 0) {
          e.preventDefault();
        }
      });
    },

    updateViewportBoundaries: function() {
      this._cachedViewportTotalPaddingBottom = undefined;
      this.$.selector.updateViewportBoundaries();
    },

    get _viewportTotalPaddingBottom() {
      if (this._cachedViewportTotalPaddingBottom === undefined) {
        var itemsStyle = window.getComputedStyle(this._unwrapIfNeeded(this.$.selector.$.items));
        this._cachedViewportTotalPaddingBottom = [
          itemsStyle.paddingBottom,
          itemsStyle.borderBottomWidth
        ].map(function(v) {
          return parseInt(v, 10);
        }).reduce(function(sum, v) {
          return sum + v;
        });
      }

      return this._cachedViewportTotalPaddingBottom;
    },

    _visibleItemsCount: function() {
      // Ensure items are rendered
      this.$.selector.flushDebouncer('_debounceTemplate');
      // Ensure items are positioned
      this.$.selector.scrollToIndex(this.$.selector.firstVisibleIndex);
      // Ensure viewport boundaries are up-to-date
      this.updateViewportBoundaries();
      return this.$.selector.lastVisibleIndex - this.$.selector.firstVisibleIndex + 1;
    },

    _selectItem: function(item) {
      item = (typeof item === 'number') ? this._items[item] : item;
      if (this.$.selector.selectedItem !== item) {
        this.$.selector.selectItem(item);
      }
    },

    _preventDefault: function(e) {
      if (e.cancelable) {
        e.preventDefault();
      }
    },

    _stopPropagation: function(e) {
      e.stopPropagation();
    }
  });
</script>
